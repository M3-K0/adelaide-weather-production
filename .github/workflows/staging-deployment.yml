name: 'Staging Environment Deployment'

on:
  workflow_dispatch:
    inputs:
      deployment_strategy:
        description: 'Deployment strategy for staging'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - recreate
          - canary
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'latest'
        type: string
      run_load_tests:
        description: 'Run load tests after deployment'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: adelaide-weather-staging-cluster
  NAMESPACE: adelaide-weather-staging
  HELM_CHART_PATH: ./helm/adelaide-weather-forecast
  REGISTRY: ghcr.io

jobs:
  # =============================================================================
  # STAGING INFRASTRUCTURE VALIDATION
  # =============================================================================
  validate-staging-infrastructure:
    name: 'Validate Staging Infrastructure'
    runs-on: ubuntu-latest
    
    outputs:
      cluster-status: ${{ steps.cluster-check.outputs.status }}
      db-status: ${{ steps.db-check.outputs.status }}
      redis-status: ${{ steps.redis-check.outputs.status }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.4'
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          
      - name: Check EKS Cluster Health
        id: cluster-check
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          
          # Check cluster status
          CLUSTER_STATUS=$(aws eks describe-cluster --name ${{ env.EKS_CLUSTER_NAME }} --query 'cluster.status' --output text)
          echo "Cluster Status: $CLUSTER_STATUS"
          
          if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
            echo "::error::EKS cluster is not in ACTIVE state: $CLUSTER_STATUS"
            exit 1
          fi
          
          # Check node readiness
          READY_NODES=$(kubectl get nodes --no-headers | grep Ready | wc -l)
          TOTAL_NODES=$(kubectl get nodes --no-headers | wc -l)
          
          echo "Ready Nodes: $READY_NODES/$TOTAL_NODES"
          
          if [ "$READY_NODES" -lt 1 ]; then
            echo "::error::No ready nodes available in the cluster"
            exit 1
          fi
          
          echo "status=healthy" >> $GITHUB_OUTPUT
          
      - name: Check Database Connectivity
        id: db-check
        run: |
          # Get RDS endpoint
          DB_ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier adelaide-weather-staging-db \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text)
          
          echo "Database Endpoint: $DB_ENDPOINT"
          
          # Test connectivity (timeout after 10 seconds)
          if timeout 10 bash -c "</dev/tcp/$DB_ENDPOINT/5432"; then
            echo "Database connectivity: OK"
            echo "status=healthy" >> $GITHUB_OUTPUT
          else
            echo "::error::Database is not accessible"
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            exit 1
          fi
          
      - name: Check Redis Connectivity
        id: redis-check
        run: |
          # Get ElastiCache endpoint
          REDIS_ENDPOINT=$(aws elasticache describe-replication-groups \
            --replication-group-id adelaide-weather-staging-cache \
            --query 'ReplicationGroups[0].NodeGroups[0].PrimaryEndpoint.Address' \
            --output text)
          
          echo "Redis Endpoint: $REDIS_ENDPOINT"
          
          # Test connectivity
          if timeout 10 bash -c "</dev/tcp/$REDIS_ENDPOINT/6379"; then
            echo "Redis connectivity: OK"
            echo "status=healthy" >> $GITHUB_OUTPUT
          else
            echo "::error::Redis is not accessible"
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            exit 1
          fi
          
      - name: Validate Terraform State
        run: |
          cd terraform/environments/staging
          terraform init
          terraform plan -detailed-exitcode
          
          if [ $? -eq 2 ]; then
            echo "::warning::Terraform detected configuration drift"
          fi

  # =============================================================================
  # STAGING DEPLOYMENT EXECUTION
  # =============================================================================
  deploy-to-staging:
    name: 'Deploy to Staging Environment'
    runs-on: ubuntu-latest
    needs: validate-staging-infrastructure
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Tools
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.2'
          
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          kubectl config current-context
          
      - name: Pre-deployment Backup
        run: |
          # Create backup of current deployment state
          kubectl get all -n ${{ env.NAMESPACE }} -o yaml > staging-backup-$(date +%Y%m%d-%H%M%S).yaml
          
      - name: Prepare Deployment Configuration
        run: |
          # Create values file for staging deployment
          cat > staging-values.yaml << EOF
          environment: staging
          
          image:
            api:
              repository: ${{ env.REGISTRY }}/adelaide-weather/api
              tag: ${{ github.event.inputs.image_tag }}
              pullPolicy: Always
            frontend:
              repository: ${{ env.REGISTRY }}/adelaide-weather/frontend
              tag: ${{ github.event.inputs.image_tag }}
              pullPolicy: Always
          
          replicaCount:
            api: 2
            frontend: 2
            
          resources:
            api:
              requests:
                memory: "512Mi"
                cpu: "250m"
              limits:
                memory: "1Gi"
                cpu: "500m"
            frontend:
              requests:
                memory: "256Mi"
                cpu: "100m"
              limits:
                memory: "512Mi"
                cpu: "200m"
          
          service:
            type: ClusterIP
            api:
              port: 8000
            frontend:
              port: 3000
          
          ingress:
            enabled: true
            className: "alb"
            annotations:
              kubernetes.io/ingress.class: alb
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-TLS-1-2-2017-01
              alb.ingress.kubernetes.io/certificate-arn: ${{ secrets.STAGING_SSL_CERT_ARN }}
            hosts:
              - host: staging.adelaide-weather.example.com
                paths:
                  - path: /api
                    pathType: Prefix
                    service: api
                  - path: /
                    pathType: Prefix
                    service: frontend
          
          database:
            host: ${{ secrets.STAGING_DB_HOST }}
            name: adelaide_weather
            user: admin
            
          redis:
            host: ${{ secrets.STAGING_REDIS_HOST }}
            port: 6379
          
          monitoring:
            enabled: true
            prometheus:
              scrape: true
          
          autoscaling:
            enabled: true
            api:
              minReplicas: 2
              maxReplicas: 5
              targetCPUUtilizationPercentage: 70
            frontend:
              minReplicas: 2
              maxReplicas: 5
              targetCPUUtilizationPercentage: 70
          EOF
          
      - name: Deploy with Rolling Update Strategy
        if: github.event.inputs.deployment_strategy == 'rolling'
        run: |
          helm upgrade --install adelaide-weather-staging ${{ env.HELM_CHART_PATH }} \
            --namespace ${{ env.NAMESPACE }} \
            --create-namespace \
            --values staging-values.yaml \
            --set deployment.strategy.type=RollingUpdate \
            --set deployment.strategy.rollingUpdate.maxUnavailable=25% \
            --set deployment.strategy.rollingUpdate.maxSurge=25% \
            --wait --timeout=15m \
            --history-max=10
            
      - name: Deploy with Recreate Strategy
        if: github.event.inputs.deployment_strategy == 'recreate'
        run: |
          helm upgrade --install adelaide-weather-staging ${{ env.HELM_CHART_PATH }} \
            --namespace ${{ env.NAMESPACE }} \
            --create-namespace \
            --values staging-values.yaml \
            --set deployment.strategy.type=Recreate \
            --wait --timeout=15m \
            --history-max=10
            
      - name: Deploy with Canary Strategy
        if: github.event.inputs.deployment_strategy == 'canary'
        run: |
          # Deploy canary version (10% of traffic)
          helm upgrade --install adelaide-weather-staging-canary ${{ env.HELM_CHART_PATH }} \
            --namespace ${{ env.NAMESPACE }} \
            --create-namespace \
            --values staging-values.yaml \
            --set deployment.suffix=canary \
            --set replicaCount.api=1 \
            --set replicaCount.frontend=1 \
            --set service.weight=10 \
            --wait --timeout=10m
            
          # Wait for canary validation
          sleep 120
          
          # If validation passes, update main deployment
          helm upgrade --install adelaide-weather-staging ${{ env.HELM_CHART_PATH }} \
            --namespace ${{ env.NAMESPACE }} \
            --values staging-values.yaml \
            --set service.weight=90 \
            --wait --timeout=15m
            
      - name: Verify Deployment Health
        run: |
          # Check deployment status
          kubectl rollout status deployment/adelaide-weather-api -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/adelaide-weather-frontend -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Check pod health
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=adelaide-weather
          
          # Verify all pods are running
          READY_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=adelaide-weather --field-selector=status.phase=Running --no-headers | wc -l)
          TOTAL_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=adelaide-weather --no-headers | wc -l)
          
          echo "Ready pods: $READY_PODS/$TOTAL_PODS"
          
          if [ "$READY_PODS" -lt "$TOTAL_PODS" ]; then
            echo "::error::Not all pods are ready"
            kubectl describe pods -n ${{ env.NAMESPACE }} -l app=adelaide-weather
            exit 1
          fi
          
      - name: Get Deployment URLs
        id: urls
        run: |
          INGRESS_HOST=$(kubectl get ingress adelaide-weather-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "Frontend URL: https://$INGRESS_HOST"
          echo "API URL: https://$INGRESS_HOST/api"
          echo "frontend_url=https://$INGRESS_HOST" >> $GITHUB_OUTPUT
          echo "api_url=https://$INGRESS_HOST/api" >> $GITHUB_OUTPUT

  # =============================================================================
  # STAGING VALIDATION AND TESTING
  # =============================================================================
  validate-staging-deployment:
    name: 'Validate Staging Deployment'
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          
      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pytest python-dotenv
          
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          
      - name: API Health Check
        run: |
          API_URL="${{ needs.deploy-to-staging.outputs.api_url }}"
          
          # Wait for API to be ready
          for i in {1..30}; do
            if curl -f "$API_URL/health" > /dev/null 2>&1; then
              echo "API health check passed"
              break
            fi
            echo "Waiting for API to be ready... ($i/30)"
            sleep 10
          done
          
          # Final health check
          curl -f "$API_URL/health" || exit 1
          
      - name: Frontend Health Check
        run: |
          FRONTEND_URL="${{ needs.deploy-to-staging.outputs.frontend_url }}"
          
          # Check frontend is responding
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL")
          
          if [ "$RESPONSE" != "200" ]; then
            echo "::error::Frontend health check failed with HTTP $RESPONSE"
            exit 1
          fi
          
          echo "Frontend health check passed"
          
      - name: Database Connectivity Test
        run: |
          # Test database connectivity through API
          API_URL="${{ needs.deploy-to-staging.outputs.api_url }}"
          
          RESPONSE=$(curl -s "$API_URL/health/database")
          
          if echo "$RESPONSE" | grep -q "healthy"; then
            echo "Database connectivity test passed"
          else
            echo "::error::Database connectivity test failed"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
      - name: Redis Connectivity Test
        run: |
          # Test Redis connectivity through API
          API_URL="${{ needs.deploy-to-staging.outputs.api_url }}"
          
          RESPONSE=$(curl -s "$API_URL/health/redis")
          
          if echo "$RESPONSE" | grep -q "healthy"; then
            echo "Redis connectivity test passed"
          else
            echo "::error::Redis connectivity test failed"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
      - name: Run Integration Tests
        run: |
          export STAGING_URL="${{ needs.deploy-to-staging.outputs.api_url }}"
          python tests/integration/staging_tests.py
          
      - name: Run API Contract Tests
        run: |
          export API_BASE_URL="${{ needs.deploy-to-staging.outputs.api_url }}"
          pytest tests/test_api_comprehensive.py -v
          
      - name: Performance Smoke Test
        run: |
          API_URL="${{ needs.deploy-to-staging.outputs.api_url }}"
          
          # Test API response time
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$API_URL/forecast")
          
          # Convert to milliseconds
          RESPONSE_TIME_MS=$(echo "$RESPONSE_TIME * 1000" | bc)
          
          echo "API response time: ${RESPONSE_TIME_MS}ms"
          
          # Check if response time is acceptable (< 2 seconds)
          if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
            echo "::warning::API response time is slower than expected: ${RESPONSE_TIME_MS}ms"
          fi

  # =============================================================================
  # LOAD TESTING (OPTIONAL)
  # =============================================================================
  run-load-tests:
    name: 'Load Testing'
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, validate-staging-deployment]
    if: github.event.inputs.run_load_tests == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js for Artillery
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install Artillery
        run: |
          npm install -g artillery
          
      - name: Configure Load Test
        run: |
          cat > load-test-config.yml << EOF
          config:
            target: '${{ needs.deploy-to-staging.outputs.api_url }}'
            phases:
              - duration: 60
                arrivalRate: 5
                name: "Warm up"
              - duration: 120
                arrivalRate: 10
                name: "Sustained load"
              - duration: 60
                arrivalRate: 20
                name: "Peak load"
            payload:
              path: "./test-data.csv"
              fields:
                - location
          scenarios:
            - name: "Forecast API Load Test"
              weight: 70
              flow:
                - get:
                    url: "/forecast"
                    capture:
                      - json: "$.forecast_id"
                        as: "forecast_id"
                - think: 2
                - get:
                    url: "/forecast/{{ forecast_id }}"
            - name: "Health Check"
              weight: 30
              flow:
                - get:
                    url: "/health"
          EOF
          
          # Create test data
          echo "location" > test-data.csv
          echo "Adelaide" >> test-data.csv
          echo "Melbourne" >> test-data.csv
          echo "Sydney" >> test-data.csv
          
      - name: Run Load Test
        run: |
          artillery run load-test-config.yml --output load-test-results.json
          
      - name: Generate Load Test Report
        run: |
          artillery report load-test-results.json --output load-test-report.html
          
      - name: Upload Load Test Results
        uses: actions/upload-artifact@v4
        with:
          name: load-test-results
          path: |
            load-test-results.json
            load-test-report.html
          retention-days: 30
          
      - name: Analyze Results
        run: |
          # Extract key metrics
          python -c "
          import json
          with open('load-test-results.json', 'r') as f:
              data = json.load(f)
          
          # Get summary stats
          summary = data.get('aggregate', {})
          
          print(f'Total Requests: {summary.get(\"requestsCompleted\", 0)}')
          print(f'Success Rate: {(1 - summary.get(\"errors\", 0) / max(summary.get(\"requestsCompleted\", 1), 1)) * 100:.2f}%')
          print(f'Average Response Time: {summary.get(\"latency\", {}).get(\"mean\", 0):.2f}ms')
          print(f'95th Percentile: {summary.get(\"latency\", {}).get(\"p95\", 0):.2f}ms')
          print(f'99th Percentile: {summary.get(\"latency\", {}).get(\"p99\", 0):.2f}ms')
          
          # Check for performance thresholds
          error_rate = summary.get('errors', 0) / max(summary.get('requestsCompleted', 1), 1)
          avg_response = summary.get('latency', {}).get('mean', 0)
          p95_response = summary.get('latency', {}).get('p95', 0)
          
          if error_rate > 0.01:  # > 1% error rate
              print('::warning::Error rate exceeds 1%')
          
          if avg_response > 1000:  # > 1 second average
              print('::warning::Average response time exceeds 1 second')
              
          if p95_response > 2000:  # > 2 seconds 95th percentile
              print('::warning::95th percentile response time exceeds 2 seconds')
          "

  # =============================================================================
  # NOTIFICATIONS AND CLEANUP
  # =============================================================================
  notify-completion:
    name: 'Notify Deployment Completion'
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, validate-staging-deployment, run-load-tests]
    if: always()
    
    steps:
      - name: Determine overall status
        id: status
        run: |
          if [[ "${{ needs.deploy-to-staging.result }}" == "success" && "${{ needs.validate-staging-deployment.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Staging deployment completed successfully" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Staging deployment failed" >> $GITHUB_OUTPUT
          fi
          
      - name: Send Slack Notification
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ steps.status.outputs.status }}
          channel: '#deployments'
          text: |
            ðŸš€ Staging Deployment Update
            Status: ${{ steps.status.outputs.message }}
            Strategy: ${{ github.event.inputs.deployment_strategy }}
            Image Tag: ${{ github.event.inputs.image_tag }}
            Load Tests: ${{ github.event.inputs.run_load_tests == 'true' && 'Executed' || 'Skipped' }}
            Actor: ${{ github.actor }}
            
            ðŸ”— View Details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      - name: Update Deployment Status
        if: always()
        run: |
          echo "Deployment completed with status: ${{ steps.status.outputs.status }}"
          echo "Deployment details saved to GitHub outputs"